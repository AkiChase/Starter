import{_ as e,W as t,X as a,a1 as o}from"./framework-c2f75a01.js";const r={},c=o('<p>介绍 <strong>Starter</strong> 中AHK Gui的编程范式，为使用Gui控件提供一个思路。</p><h2 id="驱动方式" tabindex="-1"><a class="header-anchor" href="#驱动方式" aria-hidden="true">#</a> 驱动方式</h2><h3 id="_1-事件驱动" tabindex="-1"><a class="header-anchor" href="#_1-事件驱动" aria-hidden="true">#</a> 1. 事件驱动</h3><p>传统的Gui编程是基于事件驱动</p><p>比如用户点击按钮、输入内容等事件触发回调，在回调中我们对需要改变的数据直接进行修改、对要需要改变的UI控件进行操作。</p><p>好处是简单粗暴，缺点也很明显，当某事件与很多控件、数据相关时，这个直接修改的代码写起来会非常痛苦，又臭又长。</p><h3 id="_2-数据驱动" tabindex="-1"><a class="header-anchor" href="#_2-数据驱动" aria-hidden="true">#</a> 2. 数据驱动</h3><p>而数据驱动则是另一种思想：一切皆数据，我们的UI控件表现如此是因为我们的数据如此，当我们的数据修改后，UI界面就应该根据数据表现为新的状态。</p><p>缺点是代码写起来比较复杂，优点是对于复杂的事件回调，代码反而简洁许多。</p><p>ahk v2版本的新语法中支持了比较现代的<code>class</code>、<code>getter</code>、<code>setter</code>，因此我们可以方便地使用数据驱动（相对v1版本）</p><p>数据驱动的关键是定义好数据（MVC中的<code>Model</code>）与视图（MVC中的<code>View</code>）的交互层（<code>MVC</code>中的<code>Controller</code>）</p><div class="hint-container note"><p class="hint-container-title">注</p><p>由于 <strong>Starter</strong> 一开始也是使用事件驱动，后来才尝试改用数据驱动，因此没有很好的使用MVC规范，仅供参考</p></div><h2 id="实现思路" tabindex="-1"><a class="header-anchor" href="#实现思路" aria-hidden="true">#</a> 实现思路</h2><ul><li>数据 -&gt; UI:</li></ul><p>用抽象的数据（AHK中称为动态属性）来实现。对抽象的数据进行修改可以触发抽象数据的<code>setter</code>，在其<code>setter</code>中修改真实数据(若关联到其他数据，也可以修改其他数据的抽象数据，进一步套娃触发)，并且对当前数据直接关联的UI控件进行修改。如此，实现了改变数据后UI也随之变动。</p><ul><li>UI -&gt; 数据:</li></ul><p>为UI控件设置事件回调<code>OnEvent</code>。用户的交互信息，如点击、输入内容等可以触发相应的事件回调，事件回调中修改对应抽象数据的值为当前控件的值（或其他值）。</p><ul><li>注意事项</li></ul><p>因为代码层面上对AHK控件修改不会触发其<code>OnEvent</code>，所以用户操作引起<strong>UI -&gt; 数据 -&gt; UI</strong>就终止，并不会造成死循环。其他语言环境则需要考虑在<strong>数据-&gt;UI</strong>环节中鉴别是否需要中断（比如判断对应值无变化则中断）。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>具体用法可以参考<strong>Starter</strong>源码</p></div>',20),d=[c];function n(i,s){return t(),a("div",null,d)}const l=e(r,[["render",n],["__file","ahk-gui.html.vue"]]);export{l as default};
